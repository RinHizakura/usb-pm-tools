From 2490c1436b5f7375fe78df92e29e31a86abc1ba8 Mon Sep 17 00:00:00 2001
From: Sarah Sharp <sarah@lex.(none)>
Date: Wed, 18 Jun 2008 12:56:28 -0700
Subject: [PATCH] Export if an interface driver supports autosuspend.

Create a new sysfs file per interface named supports_autosuspend.  This
file returns true if an interface driver's .supports_autosuspend flag is
set.  It also returns true if the interface is unclaimed (since the USB
core will autosuspend a device if an interface is not claimed).

This new sysfs file will be useful for user space scripts to test whether
a USB device correctly auto-suspends.

Signed-off-by: Sarah Sharp <sarah@lex.(none)>
---
 drivers/usb/core/sysfs.c |   19 +++++++++++++++++++
 1 files changed, 19 insertions(+), 0 deletions(-)

diff --git a/drivers/usb/core/sysfs.c b/drivers/usb/core/sysfs.c
index a37ccbd..9051e09 100644
--- a/drivers/usb/core/sysfs.c
+++ b/drivers/usb/core/sysfs.c
@@ -729,6 +729,24 @@ static ssize_t show_modalias(struct device *dev,
 }
 static DEVICE_ATTR(modalias, S_IRUGO, show_modalias, NULL);
 
+static ssize_t show_supports_autosuspend(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct usb_driver *driver;
+	int len;
+
+	driver = to_usb_driver(to_usb_interface(dev)->dev.driver);
+	/* Devices will be autosuspended even when an interface isn't claimed */
+	if (!driver || driver->supports_autosuspend)
+		len = sprintf(buf, "%u\n", 1);
+	else
+		len = sprintf(buf, "%u\n", 0);
+	printk(KERN_DEBUG "%s %i\n", __FUNCTION__, len);
+
+	return len;
+}
+static DEVICE_ATTR(supports_autosuspend, S_IRUGO, show_supports_autosuspend, NULL);
+
 static struct attribute *intf_assoc_attrs[] = {
 	&dev_attr_iad_bFirstInterface.attr,
 	&dev_attr_iad_bInterfaceCount.attr,
@@ -749,6 +767,7 @@ static struct attribute *intf_attrs[] = {
 	&dev_attr_bInterfaceSubClass.attr,
 	&dev_attr_bInterfaceProtocol.attr,
 	&dev_attr_modalias.attr,
+	&dev_attr_supports_autosuspend.attr,
 	NULL,
 };
 static struct attribute_group intf_attr_grp = {
-- 
1.5.3.7

